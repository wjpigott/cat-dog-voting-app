name: Deploy Cat/Dog Voting App - Multi Environment

on:
  workflow_dispatch:
    inputs:
      skip_load_test:
        description: 'Skip load testing'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: cat-dog-voting-app

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

  deploy-onprem:
    needs: build
    runs-on: self-hosted  # Use self-hosted runner for on-premises deployment
    environment: onprem
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Deploy to On-Premises Arc Cluster
      run: |
        # Update image in Kubernetes manifests
        sed -i "s|image:.*|image: ${{ needs.build.outputs.image-tag }}|g" k8s/onprem/voting-app-deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/base/ --context=arc-cluster
        kubectl apply -f k8s/onprem/ --context=arc-cluster
        
        # Wait for rollout
        kubectl rollout status deployment/voting-app --context=arc-cluster --timeout=300s

    - name: Get On-Premises Service URL
      id: onprem-url
      run: |
        ONPREM_URL=$(kubectl get svc voting-app-lb --context=arc-cluster -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "url=http://$ONPREM_URL" >> $GITHUB_OUTPUT

  deploy-azure:
    needs: build
    runs-on: ubuntu-latest
    environment: azure
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ vars.AZURE_RG }} --name ${{ vars.AKS_CLUSTER_NAME }}

    - name: Deploy to Azure AKS
      run: |
        # Update image in Kubernetes manifests
        sed -i "s|image:.*|image: ${{ needs.build.outputs.image-tag }}|g" k8s/azure/voting-app-deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/base/
        kubectl apply -f k8s/azure/
        
        # Wait for rollout
        kubectl rollout status deployment/voting-app --timeout=300s

    - name: Get Azure Service URL
      id: azure-url
      run: |
        AZURE_URL=$(kubectl get svc voting-app-lb -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "url=http://$AZURE_URL" >> $GITHUB_OUTPUT

  configure-load-balancer:
    needs: [deploy-onprem, deploy-azure]
    runs-on: ubuntu-latest
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Configure Traffic Manager
      run: |
        # Create or update Traffic Manager profile for failover
        az network traffic-manager profile create \
          --resource-group ${{ vars.AZURE_RG }} \
          --name cat-dog-voting-tm \
          --routing-method Priority \
          --unique-dns-name cat-dog-voting-${{ github.run_number }}

        # Add on-premises endpoint (higher priority)
        az network traffic-manager endpoint create \
          --resource-group ${{ vars.AZURE_RG }} \
          --profile-name cat-dog-voting-tm \
          --name onprem-endpoint \
          --type externalEndpoints \
          --target ${{ needs.deploy-onprem.outputs.url }} \
          --priority 1

        # Add Azure endpoint (lower priority for failover)
        az network traffic-manager endpoint create \
          --resource-group ${{ vars.AZURE_RG }} \
          --profile-name cat-dog-voting-tm \
          --name azure-endpoint \
          --type externalEndpoints \
          --target ${{ needs.deploy-azure.outputs.url }} \
          --priority 2

  load-test:
    if: ${{ inputs.skip_load_test != true }}
    needs: [configure-load-balancer, deploy-onprem, deploy-azure]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install Artillery
      run: npm install -g artillery@latest

    - name: Run Load Test - On Premises
      run: |
        artillery run load-tests/voting-app-load-test.yml \
          --target ${{ needs.deploy-onprem.outputs.url }} \
          --output onprem-results.json

    - name: Run Load Test - Azure
      run: |
        artillery run load-tests/voting-app-load-test.yml \
          --target ${{ needs.deploy-azure.outputs.url }} \
          --output azure-results.json

    - name: Generate Load Test Report
      run: |
        artillery report onprem-results.json --output onprem-report.html
        artillery report azure-results.json --output azure-report.html

    - name: Upload Load Test Results
      uses: actions/upload-artifact@v4
      with:
        name: load-test-results
        path: |
          onprem-results.json
          azure-results.json
          onprem-report.html
          azure-report.html

  failover-test:
    needs: [configure-load-balancer, load-test]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Test Failover Mechanism
      run: |
        echo "Testing failover from on-premises to Azure..."
        # Simulate on-premises failure by scaling down
        kubectl scale deployment voting-app --replicas=0 --context=arc-cluster || true
        
        # Wait and test Azure endpoint
        sleep 60
        curl -f ${{ needs.deploy-azure.outputs.url }}/health || exit 1
        
        echo "Failover test completed successfully"

    - name: Restore On-Premises Service
      run: |
        # Restore on-premises deployment
        kubectl scale deployment voting-app --replicas=3 --context=arc-cluster || true